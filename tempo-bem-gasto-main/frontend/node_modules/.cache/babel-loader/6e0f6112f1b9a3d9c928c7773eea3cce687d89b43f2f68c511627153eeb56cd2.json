{"ast":null,"code":"import _objectSpread from \"/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"mask\", \"pattern\"],\n  _excluded2 = [\"mask\", \"pattern\", \"blocks\"];\nimport MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport { isString } from '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\nconst DefaultPattern = 'd{.}`m{.}`Y';\n\n// Make format and parse required when pattern is provided\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  static extractPatternOptions(opts) {\n    const {\n        mask,\n        pattern\n      } = opts,\n      patternOpts = _objectWithoutProperties(opts, _excluded);\n    return _objectSpread(_objectSpread({}, patternOpts), {}, {\n      mask: isString(mask) ? mask : pattern\n    });\n  }\n\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    super(MaskedDate.extractPatternOptions(_objectSpread(_objectSpread({}, MaskedDate.DEFAULTS), opts)));\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const _MaskedDate$DEFAULTS$ = _objectSpread(_objectSpread({}, MaskedDate.DEFAULTS), opts),\n      {\n        mask,\n        pattern,\n        blocks\n      } = _MaskedDate$DEFAULTS$,\n      patternOpts = _objectWithoutProperties(_MaskedDate$DEFAULTS$, _excluded2);\n    const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\n    if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\n      patternBlocks.m.from = opts.min.getMonth() + 1;\n      patternBlocks.m.to = opts.max.getMonth() + 1;\n      if (patternBlocks.m.from === patternBlocks.m.to) {\n        patternBlocks.d.from = opts.min.getDate();\n        patternBlocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(patternBlocks, this.blocks, blocks);\n    super._update(_objectSpread(_objectSpread({}, patternOpts), {}, {\n      mask: isString(mask) ? mask : pattern,\n      blocks: patternBlocks\n    }));\n  }\n  doValidate(flags) {\n    const date = this.date;\n    return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n  optionsIsChanged(opts) {\n    return super.optionsIsChanged(MaskedDate.extractPatternOptions(opts));\n  }\n}\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nMaskedDate.DEFAULTS = _objectSpread(_objectSpread({}, MaskedPattern.DEFAULTS), {}, {\n  mask: Date,\n  pattern: DefaultPattern,\n  format: (date, masked) => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: (str, masked) => {\n    const [day, month, year] = str.split('.').map(Number);\n    return new Date(year, month - 1, day);\n  }\n});\nIMask.MaskedDate = MaskedDate;\nexport { MaskedDate as default };","map":{"version":3,"names":["MaskedPattern","MaskedRange","IMask","isString","DefaultPattern","MaskedDate","extractPatternOptions","opts","mask","pattern","patternOpts","_objectWithoutProperties","_excluded","_objectSpread","constructor","DEFAULTS","updateOptions","_update","_MaskedDate$DEFAULTS$","blocks","_excluded2","patternBlocks","Object","assign","GET_DEFAULT_BLOCKS","min","Y","from","getFullYear","max","to","m","getMonth","d","getDate","doValidate","flags","date","isComplete","isDateExist","value","str","format","parse","indexOf","typedValue","maskEquals","Date","optionsIsChanged","maxLength","masked","day","String","padStart","month","year","join","split","map","Number","default"],"sources":["/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/imask/esm/masked/date.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport { isString } from '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\nconst DefaultPattern = 'd{.}`m{.}`Y';\n\n// Make format and parse required when pattern is provided\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  static extractPatternOptions(opts) {\n    const {\n      mask,\n      pattern,\n      ...patternOpts\n    } = opts;\n    return {\n      ...patternOpts,\n      mask: isString(mask) ? mask : pattern\n    };\n  }\n\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    super(MaskedDate.extractPatternOptions({\n      ...MaskedDate.DEFAULTS,\n      ...opts\n    }));\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      mask,\n      pattern,\n      blocks,\n      ...patternOpts\n    } = {\n      ...MaskedDate.DEFAULTS,\n      ...opts\n    };\n    const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\n    if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\n      patternBlocks.m.from = opts.min.getMonth() + 1;\n      patternBlocks.m.to = opts.max.getMonth() + 1;\n      if (patternBlocks.m.from === patternBlocks.m.to) {\n        patternBlocks.d.from = opts.min.getDate();\n        patternBlocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(patternBlocks, this.blocks, blocks);\n    super._update({\n      ...patternOpts,\n      mask: isString(mask) ? mask : pattern,\n      blocks: patternBlocks\n    });\n  }\n  doValidate(flags) {\n    const date = this.date;\n    return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n  optionsIsChanged(opts) {\n    return super.optionsIsChanged(MaskedDate.extractPatternOptions(opts));\n  }\n}\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nMaskedDate.DEFAULTS = {\n  ...MaskedPattern.DEFAULTS,\n  mask: Date,\n  pattern: DefaultPattern,\n  format: (date, masked) => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: (str, masked) => {\n    const [day, month, year] = str.split('.').map(Number);\n    return new Date(year, month - 1, day);\n  }\n};\nIMask.MaskedDate = MaskedDate;\n\nexport { MaskedDate as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}