{"ast":null,"code":"import _objectWithoutProperties from \"/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"expose\"],\n  _excluded2 = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded3 = [\"mask\"];\nimport { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  constructor(opts) {\n    super(_objectSpread(_objectSpread({}, MaskedDynamic.DEFAULTS), opts));\n    this.currentMask = undefined;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      this.exposeMask = undefined;\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const _normalizeOpts = normalizeOpts(m),\n          {\n            expose\n          } = _normalizeOpts,\n          maskOpts = _objectWithoutProperties(_normalizeOpts, _excluded);\n        const masked = createMask(_objectSpread({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid\n        }, maskOpts));\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, _objectSpread({}, flags), tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return _objectSpread(_objectSpread({}, flags), {}, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.value = value;\n  }\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n      return;\n    }\n    let unmaskedValue = String(typedValue);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return _objectSpread(_objectSpread({}, super.state), {}, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutProperties(state, _excluded2);\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n  set eager(eager) {\n    this._eager = eager;\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n  get autofix() {\n    return this.currentMask ? this.currentMask.autofix : this._autofix;\n  }\n  set autofix(autofix) {\n    this._autofix = autofix;\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutProperties(_mask$mi, _excluded3);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\n/** Currently chosen mask */\n/** Currently chosen mask */\n/** Compliled {@link Masked} options */\n/** Chooses {@link Masked} depending on input value */\nMaskedDynamic.DEFAULTS = _objectSpread(_objectSpread({}, Masked.DEFAULTS), {}, {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n});\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["DIRECTION","objectIncludes","ChangeDetails","createMask","normalizeOpts","Masked","IMask","MaskedDynamic","constructor","opts","_objectSpread","DEFAULTS","currentMask","undefined","updateOptions","_update","exposeMask","compiledMasks","Array","isArray","mask","map","m","_normalizeOpts","expose","maskOpts","_objectWithoutProperties","_excluded","masked","overwrite","_overwrite","eager","_eager","skipInvalid","_skipInvalid","_appendCharRaw","ch","flags","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","length","prevMask","prevMaskState","state","doDispatch","reset","append","raw","tailShift","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","doPrepareChar","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","fromPos","toPos","_this$currentMask4","maskedState","_excluded2","mi","extractInput","extractTail","doCommit","nearestInputPos","cursorPos","direction","autofix","_autofix","maskEquals","every","_mask$mi","oldMask","restOpts","_excluded3","typedValueEquals","_this$currentMask5","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["/workspaces/pfengsw/tempo-bem-gasto-main/frontend/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = undefined;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      this.exposeMask = undefined;\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const {\n          expose,\n          ...maskOpts\n        } = normalizeOpts(m);\n        const masked = createMask({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid,\n          ...maskOpts\n        });\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.value = value;\n  }\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n      return;\n    }\n    let unmaskedValue = String(typedValue);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n  set eager(eager) {\n    this._eager = eager;\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n  get autofix() {\n    return this.currentMask ? this.currentMask.autofix : this._autofix;\n  }\n  set autofix(autofix) {\n    this._autofix = autofix;\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\n/** Currently chosen mask */\n/** Currently chosen mask */\n/** Compliled {@link Masked} options */\n/** Chooses {@link Masked} depending on input value */\nMaskedDynamic.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}